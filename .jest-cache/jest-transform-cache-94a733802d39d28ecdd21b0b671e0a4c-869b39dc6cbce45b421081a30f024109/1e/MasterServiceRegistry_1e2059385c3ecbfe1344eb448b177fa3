695d4518138c320c8308e53b93449c88
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._services = exports._masterServiceRegistry = exports._getService = exports.MasterServiceRegistry = void 0;
exports.createUnifiedServiceRegistryAdapter = createUnifiedServiceRegistryAdapter;
exports.default = void 0;
var _enhancedLogger = require("../utils/enhancedLogger");
var _UnifiedRegistryAdapter = _interopRequireDefault(require("./UnifiedRegistryAdapter"));
var _MasterServiceRegistry;
/**
 * Minimal MasterServiceRegistry
 * - Keeps API surface used across the frontend
 * - Uses `any` for external service types to avoid large refactors
 * - Uses `enhancedLogger` for logging
 */
// UnifiedServiceRegistryExternal import removed: we return a loose `unknown`
// adapter from `toUnifiedRegistry()` to avoid private-constructor type errors.
// Local interface matching the public surface of the external
// `UnifiedServiceRegistry` class. Using an interface avoids TypeScript's
// private/member class-compatibility checks when we provide a runtime
// adapter object to legacy unified services.

class MasterServiceRegistry {
  constructor() {
    this.services = new Map();
    this.serviceHealth = new Map();
    this.serviceMetrics = new Map();
    this.configuration = void 0;
    this.verboseLogging = process.env.NODE_ENV === 'development';
    this.isInitialized = false;
    this.configuration = {
      enableCaching: true,
      enableRetries: true,
      maxRetries: 3,
      timeout: 30000,
      enableMetrics: true,
      enableLogging: true,
      logLevel: 'info'
    };
  }
  static getInstance() {
    if (!MasterServiceRegistry.instance) {
      MasterServiceRegistry.instance = new MasterServiceRegistry();
    }
    return MasterServiceRegistry.instance;
  }
  async initialize() {
    if (this.isInitialized) return;
    // For now, initialization is lightweight. Services can register themselves.
    this.isInitialized = true;
    this.log('info', 'MasterServiceRegistry initialized');
  }
  registerService(name, service) {
    this.services.set(name, service);
    this.serviceMetrics.set(name, {
      totalRequests: 0,
      successRate: 100,
      averageResponseTime: 0,
      errorsLast24h: 0,
      cacheHitRate: 0,
      dataQuality: 100
    });
    this.serviceHealth.set(name, {
      name,
      status: 'healthy',
      responseTime: 0,
      lastCheck: new Date(),
      errorCount: 0,
      uptime: 100
    });
  }
  getService(name) {
    return this.services.get(name) || null;
  }
  getAllServices() {
    return new Map(this.services);
  }

  // Convenience getters return `any` to avoid introducing large type changes here
  get api() {
    return this.getService('api');
  }
  get analytics() {
    return this.getService('analytics');
  }
  get betting() {
    return this.getService('betting');
  }
  get data() {
    return this.getService('data');
  }
  get cache() {
    return this.getService('cache');
  }
  get logger() {
    return this.getService('logger');
  }
  get notifications() {
    return this.getService('notifications');
  }

  // Execute a method across all registered services if present
  async executeAcrossServices(methodName, ...args) {
    const results = new Map();
    for (const [name, svc] of this.services.entries()) {
      const service = svc;
      if (service && typeof service[methodName] === 'function') {
        try {
          const res = await service[methodName](...args);
          results.set(name, {
            success: true,
            data: res
          });
        } catch (err) {
          results.set(name, {
            success: false,
            error: err.message
          });
          this.log('error', `Service ${name} failed to execute ${methodName}`, err);
        }
      }
    }
    return results;
  }
  async refreshAllData() {
    await this.executeAcrossServices('refresh');
  }
  async clearAllCaches() {
    await this.executeAcrossServices('clearCache');
  }
  updateConfiguration(config) {
    Object.assign(this.configuration, config);
    for (const [name, svc] of this.services.entries()) {
      const service = svc;
      if (service && typeof service.updateConfiguration === 'function') {
        try {
          service.updateConfiguration(this.configuration);
        } catch (err) {
          this.log('warn', `Failed to update configuration for ${name}`, err);
        }
      }
    }
  }
  getConfiguration() {
    return {
      ...this.configuration
    };
  }
  getSystemStatistics() {
    const health = Array.from(this.serviceHealth.values());
    const metrics = Array.from(this.serviceMetrics.values());
    const totalServices = health.length;
    const healthyServices = health.filter(h => h.status === 'healthy').length;
    const degradedServices = health.filter(h => h.status === 'degraded').length;
    const downServices = health.filter(h => h.status === 'down').length;
    const averageResponseTime = totalServices ? health.reduce((s, h) => s + Math.max(0, h.responseTime), 0) / totalServices : 0;
    const totalRequests = metrics.reduce((s, m) => s + (m.totalRequests || 0), 0);
    const overallSuccessRate = metrics.length ? metrics.reduce((s, m) => s + (m.successRate || 0), 0) / metrics.length : 100;
    return {
      totalServices,
      healthyServices,
      degradedServices,
      downServices,
      averageResponseTime,
      totalRequests,
      overallSuccessRate
    };
  }
  log(level, message, err) {
    if (!this.configuration.enableLogging) return;
    try {
      const logger = this.getService('logger');
      if (logger && typeof logger[level] === 'function') {
        logger[level](message, err);
        return;
      }
    } catch {
      // fall through to enhancedLogger
    }

    // enhancedLogger expects: (component, action, message, metadata?, error?)
    const component = 'MasterServiceRegistry';
    const action = '';
    const metadata = undefined;
    switch (level) {
      case 'debug':
        _enhancedLogger.enhancedLogger.debug(component, action, message, metadata, err);
        break;
      case 'info':
        _enhancedLogger.enhancedLogger.info(component, action, message);
        break;
      case 'warn':
        _enhancedLogger.enhancedLogger.warn(component, action, message, metadata, err);
        break;
      case 'error':
        _enhancedLogger.enhancedLogger.error(component, action, message, metadata, err);
        break;
    }
  }
  async shutdown() {
    for (const [name, svc] of this.services.entries()) {
      const service = svc;
      try {
        if (service && typeof service.shutdown === 'function') {
          await service.shutdown();
        }
      } catch (err) {
        this.log('error', `Failed to shutdown service: ${name}`, err);
      }
    }
    this.services.clear();
    this.serviceHealth.clear();
    this.serviceMetrics.clear();
    this.isInitialized = false;
  }

  // Test helper: update a service health entry (used by E2E tests)
  // Minimal, safe surface that mirrors how tests expect to simulate health updates.
  updateServiceHealth(name, status, responseTime) {
    const existing = this.serviceHealth.get(name) || {
      name,
      status: 'healthy',
      responseTime: 0,
      lastCheck: new Date(),
      errorCount: 0,
      uptime: 100
    };
    const updated = {
      ...existing,
      status,
      responseTime: Math.max(0, responseTime),
      lastCheck: new Date()
    };
    this.serviceHealth.set(name, updated);
  }

  /**
   * Provide a lightweight adapter that matches the external UnifiedServiceRegistry
   * shape. We return it with a cast to the external type to minimize refactor scope.
   */
  // Return a runtime-compatible adapter but expose it with a loose type to
  // avoid TypeScript private-member/class-compatibility errors when passing
  // this adapter into existing unified services. Call sites may cast when
  // they require the concrete `UnifiedServiceRegistry` type.
  toUnifiedRegistry() {
    const adapter = new _UnifiedRegistryAdapter.default(this);

    // Create a plain object that matches the public shape of the external
    // `UnifiedServiceRegistry` so TypeScript structural checks succeed.
    const unifiedLike = {
      register: (name, service) => adapter.register(name, service),
      get: name => adapter.get(name),
      has: name => adapter.has(name),
      unregister: name => adapter.unregister(name),
      getAllServices: () => adapter.getAllServices(),
      clear: () => adapter.clear(),
      services: adapter.services
    };
    return unifiedLike;
  }

  // Expose service health map as a read-only snapshot for tests and diagnostics
  getServiceHealth(name) {
    return this.serviceHealth.get(name) || null;
  }

  // Provide a temporary alias for use by legacy unified services that expect
  // the external `UnifiedServiceRegistry` shape. This is intentionally loose
  // while we migrate callers; we'll tighten types in a follow-up.
  // Return the runtime adapter cast to the external `UnifiedServiceRegistry` shape.
  // We cast via `unknown` to avoid private-constructor/class-compatibility checks
  // while keeping the getter typed as the external interface for call sites.
  // Loosen to `any` temporarily to avoid private-member/class incompatibility
  // when passing the runtime adapter to legacy unified services. This is
  // intentionally narrow and will be tightened after remaining call-sites
  // are migrated or explicitly cast.
  get thisAsUnifiedRegistry() {
    // Return the adapter but keep callers type-stable by allowing a local cast
    // at the call-site. Some legacy unified services require the concrete
    // external class-type; callers should cast like:
    //   this.thisAsUnifiedRegistry as unknown as ExternalUnifiedServiceRegistry
    return this.toUnifiedRegistry();
  }
}

// Adapter class removed â€” use `toUnifiedRegistry()` to provide a compatible wrapper.
exports.MasterServiceRegistry = MasterServiceRegistry;
_MasterServiceRegistry = MasterServiceRegistry;
MasterServiceRegistry.instance = void 0;
const _masterServiceRegistry = exports._masterServiceRegistry = MasterServiceRegistry.getInstance();
const _getService = name => {
  return _masterServiceRegistry.getService(name);
};
exports._getService = _getService;
const _services = exports._services = {
  get api() {
    return _masterServiceRegistry.api;
  },
  get analytics() {
    return _masterServiceRegistry.analytics;
  },
  get betting() {
    return _masterServiceRegistry.betting;
  },
  get data() {
    return _masterServiceRegistry.data;
  },
  get cache() {
    return _masterServiceRegistry.cache;
  },
  get logger() {
    return _masterServiceRegistry.logger;
  },
  get notifications() {
    return _masterServiceRegistry.notifications;
  }
};
var _default = exports.default = _masterServiceRegistry; // Provide a minimal adapter shape expected by some legacy callers.
// Keep this local and narrow to avoid a large refactor.
// Adapter that implements the project's external UnifiedServiceRegistry class
// The UnifiedServiceRegistryAdapter class has been removed as it incorrectly extended a class with a private constructor.
// Compatibility exports for legacy callers that reference `UnifiedServiceRegistryAdapter`.
// Return `any` here to avoid propagating structural-check issues to legacy callers.
// Callers that need concrete typing can cast locally to the exact external type.
function createUnifiedServiceRegistryAdapter() {
  return _masterServiceRegistry.toUnifiedRegistry();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZW5oYW5jZWRMb2dnZXIiLCJyZXF1aXJlIiwiX1VuaWZpZWRSZWdpc3RyeUFkYXB0ZXIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX01hc3RlclNlcnZpY2VSZWdpc3RyeSIsIk1hc3RlclNlcnZpY2VSZWdpc3RyeSIsImNvbnN0cnVjdG9yIiwic2VydmljZXMiLCJNYXAiLCJzZXJ2aWNlSGVhbHRoIiwic2VydmljZU1ldHJpY3MiLCJjb25maWd1cmF0aW9uIiwidmVyYm9zZUxvZ2dpbmciLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJpc0luaXRpYWxpemVkIiwiZW5hYmxlQ2FjaGluZyIsImVuYWJsZVJldHJpZXMiLCJtYXhSZXRyaWVzIiwidGltZW91dCIsImVuYWJsZU1ldHJpY3MiLCJlbmFibGVMb2dnaW5nIiwibG9nTGV2ZWwiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiaW5pdGlhbGl6ZSIsImxvZyIsInJlZ2lzdGVyU2VydmljZSIsIm5hbWUiLCJzZXJ2aWNlIiwic2V0IiwidG90YWxSZXF1ZXN0cyIsInN1Y2Nlc3NSYXRlIiwiYXZlcmFnZVJlc3BvbnNlVGltZSIsImVycm9yc0xhc3QyNGgiLCJjYWNoZUhpdFJhdGUiLCJkYXRhUXVhbGl0eSIsInN0YXR1cyIsInJlc3BvbnNlVGltZSIsImxhc3RDaGVjayIsIkRhdGUiLCJlcnJvckNvdW50IiwidXB0aW1lIiwiZ2V0U2VydmljZSIsImdldCIsImdldEFsbFNlcnZpY2VzIiwiYXBpIiwiYW5hbHl0aWNzIiwiYmV0dGluZyIsImRhdGEiLCJjYWNoZSIsImxvZ2dlciIsIm5vdGlmaWNhdGlvbnMiLCJleGVjdXRlQWNyb3NzU2VydmljZXMiLCJtZXRob2ROYW1lIiwiYXJncyIsInJlc3VsdHMiLCJzdmMiLCJlbnRyaWVzIiwicmVzIiwic3VjY2VzcyIsImVyciIsImVycm9yIiwibWVzc2FnZSIsInJlZnJlc2hBbGxEYXRhIiwiY2xlYXJBbGxDYWNoZXMiLCJ1cGRhdGVDb25maWd1cmF0aW9uIiwiY29uZmlnIiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0Q29uZmlndXJhdGlvbiIsImdldFN5c3RlbVN0YXRpc3RpY3MiLCJoZWFsdGgiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJtZXRyaWNzIiwidG90YWxTZXJ2aWNlcyIsImxlbmd0aCIsImhlYWx0aHlTZXJ2aWNlcyIsImZpbHRlciIsImgiLCJkZWdyYWRlZFNlcnZpY2VzIiwiZG93blNlcnZpY2VzIiwicmVkdWNlIiwicyIsIk1hdGgiLCJtYXgiLCJtIiwib3ZlcmFsbFN1Y2Nlc3NSYXRlIiwibGV2ZWwiLCJjb21wb25lbnQiLCJhY3Rpb24iLCJtZXRhZGF0YSIsInVuZGVmaW5lZCIsImVuaGFuY2VkTG9nZ2VyIiwiZGVidWciLCJpbmZvIiwid2FybiIsInNodXRkb3duIiwiY2xlYXIiLCJ1cGRhdGVTZXJ2aWNlSGVhbHRoIiwiZXhpc3RpbmciLCJ1cGRhdGVkIiwidG9VbmlmaWVkUmVnaXN0cnkiLCJhZGFwdGVyIiwiVW5pZmllZFJlZ2lzdHJ5QWRhcHRlciIsInVuaWZpZWRMaWtlIiwicmVnaXN0ZXIiLCJoYXMiLCJ1bnJlZ2lzdGVyIiwiZ2V0U2VydmljZUhlYWx0aCIsInRoaXNBc1VuaWZpZWRSZWdpc3RyeSIsImV4cG9ydHMiLCJfbWFzdGVyU2VydmljZVJlZ2lzdHJ5IiwiX2dldFNlcnZpY2UiLCJfc2VydmljZXMiLCJfZGVmYXVsdCIsImRlZmF1bHQiLCJjcmVhdGVVbmlmaWVkU2VydmljZVJlZ2lzdHJ5QWRhcHRlciJdLCJzb3VyY2VzIjpbIk1hc3RlclNlcnZpY2VSZWdpc3RyeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTWluaW1hbCBNYXN0ZXJTZXJ2aWNlUmVnaXN0cnlcclxuICogLSBLZWVwcyBBUEkgc3VyZmFjZSB1c2VkIGFjcm9zcyB0aGUgZnJvbnRlbmRcclxuICogLSBVc2VzIGBhbnlgIGZvciBleHRlcm5hbCBzZXJ2aWNlIHR5cGVzIHRvIGF2b2lkIGxhcmdlIHJlZmFjdG9yc1xyXG4gKiAtIFVzZXMgYGVuaGFuY2VkTG9nZ2VyYCBmb3IgbG9nZ2luZ1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IGVuaGFuY2VkTG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvZW5oYW5jZWRMb2dnZXInO1xyXG4vLyBVbmlmaWVkU2VydmljZVJlZ2lzdHJ5RXh0ZXJuYWwgaW1wb3J0IHJlbW92ZWQ6IHdlIHJldHVybiBhIGxvb3NlIGB1bmtub3duYFxyXG4vLyBhZGFwdGVyIGZyb20gYHRvVW5pZmllZFJlZ2lzdHJ5KClgIHRvIGF2b2lkIHByaXZhdGUtY29uc3RydWN0b3IgdHlwZSBlcnJvcnMuXHJcbmltcG9ydCBVbmlmaWVkUmVnaXN0cnlBZGFwdGVyIGZyb20gJy4vVW5pZmllZFJlZ2lzdHJ5QWRhcHRlcic7XHJcblxyXG4vLyBMb2NhbCBpbnRlcmZhY2UgbWF0Y2hpbmcgdGhlIHB1YmxpYyBzdXJmYWNlIG9mIHRoZSBleHRlcm5hbFxyXG4vLyBgVW5pZmllZFNlcnZpY2VSZWdpc3RyeWAgY2xhc3MuIFVzaW5nIGFuIGludGVyZmFjZSBhdm9pZHMgVHlwZVNjcmlwdCdzXHJcbi8vIHByaXZhdGUvbWVtYmVyIGNsYXNzLWNvbXBhdGliaWxpdHkgY2hlY2tzIHdoZW4gd2UgcHJvdmlkZSBhIHJ1bnRpbWVcclxuLy8gYWRhcHRlciBvYmplY3QgdG8gbGVnYWN5IHVuaWZpZWQgc2VydmljZXMuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZXJuYWxVbmlmaWVkU2VydmljZVJlZ2lzdHJ5IHtcclxuICByZWdpc3RlcihuYW1lOiBzdHJpbmcsIHNlcnZpY2U6IHVua25vd24pOiB2b2lkO1xyXG4gIGdldDxUID0gdW5rbm93bj4obmFtZTogc3RyaW5nKTogVCB8IHVuZGVmaW5lZDtcclxuICBoYXMobmFtZTogc3RyaW5nKTogYm9vbGVhbjtcclxuICB1bnJlZ2lzdGVyKG5hbWU6IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgZ2V0QWxsU2VydmljZXMoKTogTWFwPHN0cmluZywgdW5rbm93bj47XHJcbiAgY2xlYXIoKTogdm9pZDtcclxuICBzZXJ2aWNlcz86IE1hcDxzdHJpbmcsIHVua25vd24+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VIZWFsdGgge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAnZG93bic7XHJcbiAgcmVzcG9uc2VUaW1lOiBudW1iZXI7XHJcbiAgbGFzdENoZWNrOiBEYXRlO1xyXG4gIGVycm9yQ291bnQ6IG51bWJlcjtcclxuICB1cHRpbWU6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlTWV0cmljcyB7XHJcbiAgdG90YWxSZXF1ZXN0czogbnVtYmVyO1xyXG4gIHN1Y2Nlc3NSYXRlOiBudW1iZXI7XHJcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogbnVtYmVyO1xyXG4gIGVycm9yc0xhc3QyNGg6IG51bWJlcjtcclxuICBjYWNoZUhpdFJhdGU6IG51bWJlcjtcclxuICBkYXRhUXVhbGl0eTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VDb25maWd1cmF0aW9uIHtcclxuICBlbmFibGVDYWNoaW5nOiBib29sZWFuO1xyXG4gIGVuYWJsZVJldHJpZXM6IGJvb2xlYW47XHJcbiAgbWF4UmV0cmllczogbnVtYmVyO1xyXG4gIHRpbWVvdXQ6IG51bWJlcjtcclxuICBlbmFibGVNZXRyaWNzOiBib29sZWFuO1xyXG4gIGVuYWJsZUxvZ2dpbmc6IGJvb2xlYW47XHJcbiAgbG9nTGV2ZWw6ICdkZWJ1ZycgfCAnaW5mbycgfCAnd2FybicgfCAnZXJyb3InO1xyXG59XHJcblxyXG5jbGFzcyBNYXN0ZXJTZXJ2aWNlUmVnaXN0cnkge1xyXG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBNYXN0ZXJTZXJ2aWNlUmVnaXN0cnk7XHJcbiAgcHJpdmF0ZSBzZXJ2aWNlczogTWFwPHN0cmluZywgdW5rbm93bj4gPSBuZXcgTWFwKCk7XHJcbiAgcHJpdmF0ZSBzZXJ2aWNlSGVhbHRoOiBNYXA8c3RyaW5nLCBTZXJ2aWNlSGVhbHRoPiA9IG5ldyBNYXAoKTtcclxuICBwcml2YXRlIHNlcnZpY2VNZXRyaWNzOiBNYXA8c3RyaW5nLCBTZXJ2aWNlTWV0cmljcz4gPSBuZXcgTWFwKCk7XHJcbiAgcHVibGljIHJlYWRvbmx5IGNvbmZpZ3VyYXRpb246IFNlcnZpY2VDb25maWd1cmF0aW9uO1xyXG4gIHB1YmxpYyB2ZXJib3NlTG9nZ2luZzogYm9vbGVhbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xyXG4gIHByaXZhdGUgaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0ge1xyXG4gICAgICBlbmFibGVDYWNoaW5nOiB0cnVlLFxyXG4gICAgICBlbmFibGVSZXRyaWVzOiB0cnVlLFxyXG4gICAgICBtYXhSZXRyaWVzOiAzLFxyXG4gICAgICB0aW1lb3V0OiAzMDAwMCxcclxuICAgICAgZW5hYmxlTWV0cmljczogdHJ1ZSxcclxuICAgICAgZW5hYmxlTG9nZ2luZzogdHJ1ZSxcclxuICAgICAgbG9nTGV2ZWw6ICdpbmZvJyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuXHJcbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IE1hc3RlclNlcnZpY2VSZWdpc3RyeSB7XHJcbiAgICBpZiAoIU1hc3RlclNlcnZpY2VSZWdpc3RyeS5pbnN0YW5jZSkge1xyXG4gICAgICBNYXN0ZXJTZXJ2aWNlUmVnaXN0cnkuaW5zdGFuY2UgPSBuZXcgTWFzdGVyU2VydmljZVJlZ2lzdHJ5KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWFzdGVyU2VydmljZVJlZ2lzdHJ5Lmluc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybjtcclxuICAgIC8vIEZvciBub3csIGluaXRpYWxpemF0aW9uIGlzIGxpZ2h0d2VpZ2h0LiBTZXJ2aWNlcyBjYW4gcmVnaXN0ZXIgdGhlbXNlbHZlcy5cclxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB0aGlzLmxvZygnaW5mbycsICdNYXN0ZXJTZXJ2aWNlUmVnaXN0cnkgaW5pdGlhbGl6ZWQnKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZWdpc3RlclNlcnZpY2UobmFtZTogc3RyaW5nLCBzZXJ2aWNlOiB1bmtub3duKTogdm9pZCB7XHJcbiAgICB0aGlzLnNlcnZpY2VzLnNldChuYW1lLCBzZXJ2aWNlKTtcclxuICAgIHRoaXMuc2VydmljZU1ldHJpY3Muc2V0KG5hbWUsIHtcclxuICAgICAgdG90YWxSZXF1ZXN0czogMCxcclxuICAgICAgc3VjY2Vzc1JhdGU6IDEwMCxcclxuICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogMCxcclxuICAgICAgZXJyb3JzTGFzdDI0aDogMCxcclxuICAgICAgY2FjaGVIaXRSYXRlOiAwLFxyXG4gICAgICBkYXRhUXVhbGl0eTogMTAwLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNlcnZpY2VIZWFsdGguc2V0KG5hbWUsIHtcclxuICAgICAgbmFtZSxcclxuICAgICAgc3RhdHVzOiAnaGVhbHRoeScsXHJcbiAgICAgIHJlc3BvbnNlVGltZTogMCxcclxuICAgICAgbGFzdENoZWNrOiBuZXcgRGF0ZSgpLFxyXG4gICAgICBlcnJvckNvdW50OiAwLFxyXG4gICAgICB1cHRpbWU6IDEwMCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0U2VydmljZTxUID0gdW5rbm93bj4obmFtZTogc3RyaW5nKTogVCB8IG51bGwge1xyXG4gICAgcmV0dXJuICh0aGlzLnNlcnZpY2VzLmdldChuYW1lKSBhcyBUKSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0QWxsU2VydmljZXMoKTogTWFwPHN0cmluZywgdW5rbm93bj4ge1xyXG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5zZXJ2aWNlcyk7XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZW5pZW5jZSBnZXR0ZXJzIHJldHVybiBgYW55YCB0byBhdm9pZCBpbnRyb2R1Y2luZyBsYXJnZSB0eXBlIGNoYW5nZXMgaGVyZVxyXG4gIGdldCBhcGkoKTogdW5rbm93biB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKCdhcGknKTtcclxuICB9XHJcblxyXG4gIGdldCBhbmFseXRpY3MoKTogdW5rbm93biB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKCdhbmFseXRpY3MnKTtcclxuICB9XHJcblxyXG4gIGdldCBiZXR0aW5nKCk6IHVua25vd24ge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VydmljZSgnYmV0dGluZycpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRhdGEoKTogdW5rbm93biB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKCdkYXRhJyk7XHJcbiAgfVxyXG5cclxuICBnZXQgY2FjaGUoKTogdW5rbm93biB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKCdjYWNoZScpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxvZ2dlcigpOiB1bmtub3duIHtcclxuICAgIHJldHVybiB0aGlzLmdldFNlcnZpY2UoJ2xvZ2dlcicpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG5vdGlmaWNhdGlvbnMoKTogdW5rbm93biB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKCdub3RpZmljYXRpb25zJyk7XHJcbiAgfVxyXG5cclxuICAvLyBFeGVjdXRlIGEgbWV0aG9kIGFjcm9zcyBhbGwgcmVnaXN0ZXJlZCBzZXJ2aWNlcyBpZiBwcmVzZW50XHJcbiAgYXN5bmMgZXhlY3V0ZUFjcm9zc1NlcnZpY2VzKG1ldGhvZE5hbWU6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKTogUHJvbWlzZTxNYXA8c3RyaW5nLCB1bmtub3duPj4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBNYXA8c3RyaW5nLCB1bmtub3duPigpO1xyXG4gICAgZm9yIChjb25zdCBbbmFtZSwgc3ZjXSBvZiB0aGlzLnNlcnZpY2VzLmVudHJpZXMoKSkge1xyXG4gIGNvbnN0IHNlcnZpY2UgPSBzdmMgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICAgICAgaWYgKHNlcnZpY2UgJiYgdHlwZW9mIHNlcnZpY2VbbWV0aG9kTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgc2VydmljZVttZXRob2ROYW1lXSguLi5hcmdzKTtcclxuICAgICAgICAgIHJlc3VsdHMuc2V0KG5hbWUsIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgcmVzdWx0cy5zZXQobmFtZSwgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UgfSk7XHJcbiAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCBgU2VydmljZSAke25hbWV9IGZhaWxlZCB0byBleGVjdXRlICR7bWV0aG9kTmFtZX1gLCBlcnIgYXMgRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZWZyZXNoQWxsRGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUFjcm9zc1NlcnZpY2VzKCdyZWZyZXNoJyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjbGVhckFsbENhY2hlcygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUFjcm9zc1NlcnZpY2VzKCdjbGVhckNhY2hlJyk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZzogUGFydGlhbDxTZXJ2aWNlQ29uZmlndXJhdGlvbj4pOiB2b2lkIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWd1cmF0aW9uLCBjb25maWcpO1xyXG4gICAgZm9yIChjb25zdCBbbmFtZSwgc3ZjXSBvZiB0aGlzLnNlcnZpY2VzLmVudHJpZXMoKSkge1xyXG4gIGNvbnN0IHNlcnZpY2UgPSBzdmMgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICAgICAgaWYgKHNlcnZpY2UgJiYgdHlwZW9mIHNlcnZpY2UudXBkYXRlQ29uZmlndXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzZXJ2aWNlLnVwZGF0ZUNvbmZpZ3VyYXRpb24odGhpcy5jb25maWd1cmF0aW9uKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIHRoaXMubG9nKCd3YXJuJywgYEZhaWxlZCB0byB1cGRhdGUgY29uZmlndXJhdGlvbiBmb3IgJHtuYW1lfWAsIGVyciBhcyBFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRDb25maWd1cmF0aW9uKCk6IFNlcnZpY2VDb25maWd1cmF0aW9uIHtcclxuICAgIHJldHVybiB7IC4uLnRoaXMuY29uZmlndXJhdGlvbiB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0U3lzdGVtU3RhdGlzdGljcygpIHtcclxuICAgIGNvbnN0IGhlYWx0aCA9IEFycmF5LmZyb20odGhpcy5zZXJ2aWNlSGVhbHRoLnZhbHVlcygpKTtcclxuICAgIGNvbnN0IG1ldHJpY3MgPSBBcnJheS5mcm9tKHRoaXMuc2VydmljZU1ldHJpY3MudmFsdWVzKCkpO1xyXG4gICAgY29uc3QgdG90YWxTZXJ2aWNlcyA9IGhlYWx0aC5sZW5ndGg7XHJcbiAgICBjb25zdCBoZWFsdGh5U2VydmljZXMgPSBoZWFsdGguZmlsdGVyKGggPT4gaC5zdGF0dXMgPT09ICdoZWFsdGh5JykubGVuZ3RoO1xyXG4gICAgY29uc3QgZGVncmFkZWRTZXJ2aWNlcyA9IGhlYWx0aC5maWx0ZXIoaCA9PiBoLnN0YXR1cyA9PT0gJ2RlZ3JhZGVkJykubGVuZ3RoO1xyXG4gICAgY29uc3QgZG93blNlcnZpY2VzID0gaGVhbHRoLmZpbHRlcihoID0+IGguc3RhdHVzID09PSAnZG93bicpLmxlbmd0aDtcclxuICAgIGNvbnN0IGF2ZXJhZ2VSZXNwb25zZVRpbWUgPSB0b3RhbFNlcnZpY2VzID8gaGVhbHRoLnJlZHVjZSgocywgaCkgPT4gcyArIE1hdGgubWF4KDAsIGgucmVzcG9uc2VUaW1lKSwgMCkgLyB0b3RhbFNlcnZpY2VzIDogMDtcclxuICAgIGNvbnN0IHRvdGFsUmVxdWVzdHMgPSBtZXRyaWNzLnJlZHVjZSgocywgbSkgPT4gcyArIChtLnRvdGFsUmVxdWVzdHMgfHwgMCksIDApO1xyXG4gICAgY29uc3Qgb3ZlcmFsbFN1Y2Nlc3NSYXRlID0gbWV0cmljcy5sZW5ndGggPyBtZXRyaWNzLnJlZHVjZSgocywgbSkgPT4gcyArIChtLnN1Y2Nlc3NSYXRlIHx8IDApLCAwKSAvIG1ldHJpY3MubGVuZ3RoIDogMTAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxTZXJ2aWNlcyxcclxuICAgICAgaGVhbHRoeVNlcnZpY2VzLFxyXG4gICAgICBkZWdyYWRlZFNlcnZpY2VzLFxyXG4gICAgICBkb3duU2VydmljZXMsXHJcbiAgICAgIGF2ZXJhZ2VSZXNwb25zZVRpbWUsXHJcbiAgICAgIHRvdGFsUmVxdWVzdHMsXHJcbiAgICAgIG92ZXJhbGxTdWNjZXNzUmF0ZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGxvZyhsZXZlbDogJ2RlYnVnJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcicsIG1lc3NhZ2U6IHN0cmluZywgZXJyPzogdW5rbm93bik6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRpb24uZW5hYmxlTG9nZ2luZykgcmV0dXJuO1xyXG4gICAgdHJ5IHtcclxuICBjb25zdCBsb2dnZXIgPSB0aGlzLmdldFNlcnZpY2UoJ2xvZ2dlcicpIGFzIHVua25vd24gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsO1xyXG4gICAgICBpZiAobG9nZ2VyICYmIHR5cGVvZiBsb2dnZXJbbGV2ZWxdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgbG9nZ2VyW2xldmVsXShtZXNzYWdlLCBlcnIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byBlbmhhbmNlZExvZ2dlclxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVuaGFuY2VkTG9nZ2VyIGV4cGVjdHM6IChjb21wb25lbnQsIGFjdGlvbiwgbWVzc2FnZSwgbWV0YWRhdGE/LCBlcnJvcj8pXHJcbiAgICBjb25zdCBjb21wb25lbnQgPSAnTWFzdGVyU2VydmljZVJlZ2lzdHJ5JztcclxuICAgIGNvbnN0IGFjdGlvbiA9ICcnO1xyXG4gICAgY29uc3QgbWV0YWRhdGEgPSB1bmRlZmluZWQgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICBzd2l0Y2ggKGxldmVsKSB7XHJcbiAgICAgIGNhc2UgJ2RlYnVnJzpcclxuICAgICAgICBlbmhhbmNlZExvZ2dlci5kZWJ1Zyhjb21wb25lbnQsIGFjdGlvbiwgbWVzc2FnZSwgbWV0YWRhdGEsIGVyciBhcyBFcnJvciB8IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2luZm8nOlxyXG4gICAgICAgIGVuaGFuY2VkTG9nZ2VyLmluZm8oY29tcG9uZW50LCBhY3Rpb24sIG1lc3NhZ2UpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd3YXJuJzpcclxuICAgICAgICBlbmhhbmNlZExvZ2dlci53YXJuKGNvbXBvbmVudCwgYWN0aW9uLCBtZXNzYWdlLCBtZXRhZGF0YSwgZXJyIGFzIEVycm9yIHwgdW5kZWZpbmVkKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZXJyb3InOlxyXG4gICAgICAgIGVuaGFuY2VkTG9nZ2VyLmVycm9yKGNvbXBvbmVudCwgYWN0aW9uLCBtZXNzYWdlLCBtZXRhZGF0YSwgZXJyIGFzIEVycm9yIHwgdW5kZWZpbmVkKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHNodXRkb3duKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgZm9yIChjb25zdCBbbmFtZSwgc3ZjXSBvZiB0aGlzLnNlcnZpY2VzLmVudHJpZXMoKSkge1xyXG4gIGNvbnN0IHNlcnZpY2UgPSBzdmMgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoc2VydmljZSAmJiB0eXBlb2Ygc2VydmljZS5zaHV0ZG93biA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgYXdhaXQgc2VydmljZS5zaHV0ZG93bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYEZhaWxlZCB0byBzaHV0ZG93biBzZXJ2aWNlOiAke25hbWV9YCwgZXJyIGFzIEVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5zZXJ2aWNlcy5jbGVhcigpO1xyXG4gICAgdGhpcy5zZXJ2aWNlSGVhbHRoLmNsZWFyKCk7XHJcbiAgICB0aGlzLnNlcnZpY2VNZXRyaWNzLmNsZWFyKCk7XHJcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIFRlc3QgaGVscGVyOiB1cGRhdGUgYSBzZXJ2aWNlIGhlYWx0aCBlbnRyeSAodXNlZCBieSBFMkUgdGVzdHMpXHJcbiAgLy8gTWluaW1hbCwgc2FmZSBzdXJmYWNlIHRoYXQgbWlycm9ycyBob3cgdGVzdHMgZXhwZWN0IHRvIHNpbXVsYXRlIGhlYWx0aCB1cGRhdGVzLlxyXG4gIHB1YmxpYyB1cGRhdGVTZXJ2aWNlSGVhbHRoKG5hbWU6IHN0cmluZywgc3RhdHVzOiBTZXJ2aWNlSGVhbHRoWydzdGF0dXMnXSwgcmVzcG9uc2VUaW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5zZXJ2aWNlSGVhbHRoLmdldChuYW1lKSB8fCB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHN0YXR1czogJ2hlYWx0aHknIGFzIFNlcnZpY2VIZWFsdGhbJ3N0YXR1cyddLFxyXG4gICAgICByZXNwb25zZVRpbWU6IDAsXHJcbiAgICAgIGxhc3RDaGVjazogbmV3IERhdGUoKSxcclxuICAgICAgZXJyb3JDb3VudDogMCxcclxuICAgICAgdXB0aW1lOiAxMDAsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlZDogU2VydmljZUhlYWx0aCA9IHtcclxuICAgICAgLi4uZXhpc3RpbmcsXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgcmVzcG9uc2VUaW1lOiBNYXRoLm1heCgwLCByZXNwb25zZVRpbWUpLFxyXG4gICAgICBsYXN0Q2hlY2s6IG5ldyBEYXRlKCksXHJcbiAgICB9O1xyXG4gICAgdGhpcy5zZXJ2aWNlSGVhbHRoLnNldChuYW1lLCB1cGRhdGVkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByb3ZpZGUgYSBsaWdodHdlaWdodCBhZGFwdGVyIHRoYXQgbWF0Y2hlcyB0aGUgZXh0ZXJuYWwgVW5pZmllZFNlcnZpY2VSZWdpc3RyeVxyXG4gICAqIHNoYXBlLiBXZSByZXR1cm4gaXQgd2l0aCBhIGNhc3QgdG8gdGhlIGV4dGVybmFsIHR5cGUgdG8gbWluaW1pemUgcmVmYWN0b3Igc2NvcGUuXHJcbiAgICovXHJcbiAgLy8gUmV0dXJuIGEgcnVudGltZS1jb21wYXRpYmxlIGFkYXB0ZXIgYnV0IGV4cG9zZSBpdCB3aXRoIGEgbG9vc2UgdHlwZSB0b1xyXG4gIC8vIGF2b2lkIFR5cGVTY3JpcHQgcHJpdmF0ZS1tZW1iZXIvY2xhc3MtY29tcGF0aWJpbGl0eSBlcnJvcnMgd2hlbiBwYXNzaW5nXHJcbiAgLy8gdGhpcyBhZGFwdGVyIGludG8gZXhpc3RpbmcgdW5pZmllZCBzZXJ2aWNlcy4gQ2FsbCBzaXRlcyBtYXkgY2FzdCB3aGVuXHJcbiAgLy8gdGhleSByZXF1aXJlIHRoZSBjb25jcmV0ZSBgVW5pZmllZFNlcnZpY2VSZWdpc3RyeWAgdHlwZS5cclxuICBwdWJsaWMgdG9VbmlmaWVkUmVnaXN0cnkoKTogRXh0ZXJuYWxVbmlmaWVkU2VydmljZVJlZ2lzdHJ5ICYgeyBzZXJ2aWNlczogTWFwPHN0cmluZywgdW5rbm93bj47IGdldEFsbFNlcnZpY2VzKCk6IE1hcDxzdHJpbmcsIHVua25vd24+IH0ge1xyXG4gICAgY29uc3QgYWRhcHRlciA9IG5ldyBVbmlmaWVkUmVnaXN0cnlBZGFwdGVyKHRoaXMpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIHBsYWluIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIHB1YmxpYyBzaGFwZSBvZiB0aGUgZXh0ZXJuYWxcclxuICAgIC8vIGBVbmlmaWVkU2VydmljZVJlZ2lzdHJ5YCBzbyBUeXBlU2NyaXB0IHN0cnVjdHVyYWwgY2hlY2tzIHN1Y2NlZWQuXHJcbiAgY29uc3QgdW5pZmllZExpa2UgPSB7XHJcbiAgICAgIHJlZ2lzdGVyOiAobmFtZTogc3RyaW5nLCBzZXJ2aWNlOiB1bmtub3duKSA9PiBhZGFwdGVyLnJlZ2lzdGVyKG5hbWUsIHNlcnZpY2UpLFxyXG4gICAgICBnZXQ6IDxUID0gdW5rbm93bj4obmFtZTogc3RyaW5nKSA9PiBhZGFwdGVyLmdldDxUPihuYW1lKSxcclxuICAgICAgaGFzOiAobmFtZTogc3RyaW5nKSA9PiBhZGFwdGVyLmhhcyhuYW1lKSxcclxuICAgICAgdW5yZWdpc3RlcjogKG5hbWU6IHN0cmluZykgPT4gYWRhcHRlci51bnJlZ2lzdGVyKG5hbWUpLFxyXG4gICAgICBnZXRBbGxTZXJ2aWNlczogKCkgPT4gYWRhcHRlci5nZXRBbGxTZXJ2aWNlcygpLFxyXG4gICAgICBjbGVhcjogKCkgPT4gYWRhcHRlci5jbGVhcigpLFxyXG4gICAgICBzZXJ2aWNlczogYWRhcHRlci5zZXJ2aWNlcyxcclxuICB9IGFzIHVua25vd24gYXMgRXh0ZXJuYWxVbmlmaWVkU2VydmljZVJlZ2lzdHJ5ICYgeyBzZXJ2aWNlczogTWFwPHN0cmluZywgdW5rbm93bj47IGdldEFsbFNlcnZpY2VzKCk6IE1hcDxzdHJpbmcsIHVua25vd24+IH07XHJcblxyXG4gICAgcmV0dXJuIHVuaWZpZWRMaWtlO1xyXG4gIH1cclxuXHJcbiAgLy8gRXhwb3NlIHNlcnZpY2UgaGVhbHRoIG1hcCBhcyBhIHJlYWQtb25seSBzbmFwc2hvdCBmb3IgdGVzdHMgYW5kIGRpYWdub3N0aWNzXHJcbiAgcHVibGljIGdldFNlcnZpY2VIZWFsdGgobmFtZTogc3RyaW5nKTogU2VydmljZUhlYWx0aCB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VydmljZUhlYWx0aC5nZXQobmFtZSkgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIFByb3ZpZGUgYSB0ZW1wb3JhcnkgYWxpYXMgZm9yIHVzZSBieSBsZWdhY3kgdW5pZmllZCBzZXJ2aWNlcyB0aGF0IGV4cGVjdFxyXG4gIC8vIHRoZSBleHRlcm5hbCBgVW5pZmllZFNlcnZpY2VSZWdpc3RyeWAgc2hhcGUuIFRoaXMgaXMgaW50ZW50aW9uYWxseSBsb29zZVxyXG4gIC8vIHdoaWxlIHdlIG1pZ3JhdGUgY2FsbGVyczsgd2UnbGwgdGlnaHRlbiB0eXBlcyBpbiBhIGZvbGxvdy11cC5cclxuICAvLyBSZXR1cm4gdGhlIHJ1bnRpbWUgYWRhcHRlciBjYXN0IHRvIHRoZSBleHRlcm5hbCBgVW5pZmllZFNlcnZpY2VSZWdpc3RyeWAgc2hhcGUuXHJcbiAgLy8gV2UgY2FzdCB2aWEgYHVua25vd25gIHRvIGF2b2lkIHByaXZhdGUtY29uc3RydWN0b3IvY2xhc3MtY29tcGF0aWJpbGl0eSBjaGVja3NcclxuICAvLyB3aGlsZSBrZWVwaW5nIHRoZSBnZXR0ZXIgdHlwZWQgYXMgdGhlIGV4dGVybmFsIGludGVyZmFjZSBmb3IgY2FsbCBzaXRlcy5cclxuICAvLyBMb29zZW4gdG8gYGFueWAgdGVtcG9yYXJpbHkgdG8gYXZvaWQgcHJpdmF0ZS1tZW1iZXIvY2xhc3MgaW5jb21wYXRpYmlsaXR5XHJcbiAgLy8gd2hlbiBwYXNzaW5nIHRoZSBydW50aW1lIGFkYXB0ZXIgdG8gbGVnYWN5IHVuaWZpZWQgc2VydmljZXMuIFRoaXMgaXNcclxuICAvLyBpbnRlbnRpb25hbGx5IG5hcnJvdyBhbmQgd2lsbCBiZSB0aWdodGVuZWQgYWZ0ZXIgcmVtYWluaW5nIGNhbGwtc2l0ZXNcclxuICAvLyBhcmUgbWlncmF0ZWQgb3IgZXhwbGljaXRseSBjYXN0LlxyXG4gIHByaXZhdGUgZ2V0IHRoaXNBc1VuaWZpZWRSZWdpc3RyeSgpOiBhbnkge1xyXG4gIC8vIFJldHVybiB0aGUgYWRhcHRlciBidXQga2VlcCBjYWxsZXJzIHR5cGUtc3RhYmxlIGJ5IGFsbG93aW5nIGEgbG9jYWwgY2FzdFxyXG4gIC8vIGF0IHRoZSBjYWxsLXNpdGUuIFNvbWUgbGVnYWN5IHVuaWZpZWQgc2VydmljZXMgcmVxdWlyZSB0aGUgY29uY3JldGVcclxuICAvLyBleHRlcm5hbCBjbGFzcy10eXBlOyBjYWxsZXJzIHNob3VsZCBjYXN0IGxpa2U6XHJcbiAgLy8gICB0aGlzLnRoaXNBc1VuaWZpZWRSZWdpc3RyeSBhcyB1bmtub3duIGFzIEV4dGVybmFsVW5pZmllZFNlcnZpY2VSZWdpc3RyeVxyXG4gIHJldHVybiB0aGlzLnRvVW5pZmllZFJlZ2lzdHJ5KCkgYXMgdW5rbm93biBhcyBFeHRlcm5hbFVuaWZpZWRTZXJ2aWNlUmVnaXN0cnkgJiB7IHNlcnZpY2VzOiBNYXA8c3RyaW5nLCB1bmtub3duPjsgZ2V0QWxsU2VydmljZXMoKTogTWFwPHN0cmluZywgdW5rbm93bj4gfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEFkYXB0ZXIgY2xhc3MgcmVtb3ZlZCDigJQgdXNlIGB0b1VuaWZpZWRSZWdpc3RyeSgpYCB0byBwcm92aWRlIGEgY29tcGF0aWJsZSB3cmFwcGVyLlxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBfbWFzdGVyU2VydmljZVJlZ2lzdHJ5ID0gTWFzdGVyU2VydmljZVJlZ2lzdHJ5LmdldEluc3RhbmNlKCk7XHJcblxyXG5leHBvcnQgY29uc3QgX2dldFNlcnZpY2UgPSA8VCA9IHVua25vd24+KG5hbWU6IHN0cmluZyk6IFQgfCBudWxsID0+IHtcclxuICByZXR1cm4gX21hc3RlclNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlPFQ+KG5hbWUpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IF9zZXJ2aWNlcyA9IHtcclxuICBnZXQgYXBpKCkge1xyXG4gICAgcmV0dXJuIF9tYXN0ZXJTZXJ2aWNlUmVnaXN0cnkuYXBpO1xyXG4gIH0sXHJcbiAgZ2V0IGFuYWx5dGljcygpIHtcclxuICAgIHJldHVybiBfbWFzdGVyU2VydmljZVJlZ2lzdHJ5LmFuYWx5dGljcztcclxuICB9LFxyXG4gIGdldCBiZXR0aW5nKCkge1xyXG4gICAgcmV0dXJuIF9tYXN0ZXJTZXJ2aWNlUmVnaXN0cnkuYmV0dGluZztcclxuICB9LFxyXG4gIGdldCBkYXRhKCkge1xyXG4gICAgcmV0dXJuIF9tYXN0ZXJTZXJ2aWNlUmVnaXN0cnkuZGF0YTtcclxuICB9LFxyXG4gIGdldCBjYWNoZSgpIHtcclxuICAgIHJldHVybiBfbWFzdGVyU2VydmljZVJlZ2lzdHJ5LmNhY2hlO1xyXG4gIH0sXHJcbiAgZ2V0IGxvZ2dlcigpIHtcclxuICAgIHJldHVybiBfbWFzdGVyU2VydmljZVJlZ2lzdHJ5LmxvZ2dlcjtcclxuICB9LFxyXG4gIGdldCBub3RpZmljYXRpb25zKCkge1xyXG4gICAgcmV0dXJuIF9tYXN0ZXJTZXJ2aWNlUmVnaXN0cnkubm90aWZpY2F0aW9ucztcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IHsgTWFzdGVyU2VydmljZVJlZ2lzdHJ5IH07XHJcbmV4cG9ydCBkZWZhdWx0IF9tYXN0ZXJTZXJ2aWNlUmVnaXN0cnk7XHJcblxyXG4vLyBQcm92aWRlIGEgbWluaW1hbCBhZGFwdGVyIHNoYXBlIGV4cGVjdGVkIGJ5IHNvbWUgbGVnYWN5IGNhbGxlcnMuXHJcbi8vIEtlZXAgdGhpcyBsb2NhbCBhbmQgbmFycm93IHRvIGF2b2lkIGEgbGFyZ2UgcmVmYWN0b3IuXHJcbi8vIEFkYXB0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBwcm9qZWN0J3MgZXh0ZXJuYWwgVW5pZmllZFNlcnZpY2VSZWdpc3RyeSBjbGFzc1xyXG4vLyBUaGUgVW5pZmllZFNlcnZpY2VSZWdpc3RyeUFkYXB0ZXIgY2xhc3MgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpbmNvcnJlY3RseSBleHRlbmRlZCBhIGNsYXNzIHdpdGggYSBwcml2YXRlIGNvbnN0cnVjdG9yLlxyXG5cclxuLy8gQ29tcGF0aWJpbGl0eSBleHBvcnRzIGZvciBsZWdhY3kgY2FsbGVycyB0aGF0IHJlZmVyZW5jZSBgVW5pZmllZFNlcnZpY2VSZWdpc3RyeUFkYXB0ZXJgLlxyXG5leHBvcnQgdHlwZSBVbmlmaWVkU2VydmljZVJlZ2lzdHJ5QWRhcHRlciA9IEV4dGVybmFsVW5pZmllZFNlcnZpY2VSZWdpc3RyeSAmIHsgc2VydmljZXM6IE1hcDxzdHJpbmcsIHVua25vd24+OyBnZXRBbGxTZXJ2aWNlcygpOiBNYXA8c3RyaW5nLCB1bmtub3duPiB9O1xyXG5cclxuLy8gUmV0dXJuIGBhbnlgIGhlcmUgdG8gYXZvaWQgcHJvcGFnYXRpbmcgc3RydWN0dXJhbC1jaGVjayBpc3N1ZXMgdG8gbGVnYWN5IGNhbGxlcnMuXHJcbi8vIENhbGxlcnMgdGhhdCBuZWVkIGNvbmNyZXRlIHR5cGluZyBjYW4gY2FzdCBsb2NhbGx5IHRvIHRoZSBleGFjdCBleHRlcm5hbCB0eXBlLlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVW5pZmllZFNlcnZpY2VSZWdpc3RyeUFkYXB0ZXIoKTogVW5pZmllZFNlcnZpY2VSZWdpc3RyeUFkYXB0ZXIge1xyXG4gIHJldHVybiBfbWFzdGVyU2VydmljZVJlZ2lzdHJ5LnRvVW5pZmllZFJlZ2lzdHJ5KCkgYXMgdW5rbm93biBhcyBVbmlmaWVkU2VydmljZVJlZ2lzdHJ5QWRhcHRlcjtcclxufVxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQU9BLElBQUFBLGVBQUEsR0FBQUMsT0FBQTtBQUdBLElBQUFDLHVCQUFBLEdBQUFDLHNCQUFBLENBQUFGLE9BQUE7QUFBOEQsSUFBQUcsc0JBQUE7QUFWOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQXVDQSxNQUFNQyxxQkFBcUIsQ0FBQztFQVNsQkMsV0FBV0EsQ0FBQSxFQUFHO0lBQUEsS0FQZEMsUUFBUSxHQUF5QixJQUFJQyxHQUFHLENBQUMsQ0FBQztJQUFBLEtBQzFDQyxhQUFhLEdBQStCLElBQUlELEdBQUcsQ0FBQyxDQUFDO0lBQUEsS0FDckRFLGNBQWMsR0FBZ0MsSUFBSUYsR0FBRyxDQUFDLENBQUM7SUFBQSxLQUMvQ0csYUFBYTtJQUFBLEtBQ3RCQyxjQUFjLEdBQVlDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDQyxRQUFRLEtBQUssYUFBYTtJQUFBLEtBQy9EQyxhQUFhLEdBQUcsS0FBSztJQUczQixJQUFJLENBQUNMLGFBQWEsR0FBRztNQUNuQk0sYUFBYSxFQUFFLElBQUk7TUFDbkJDLGFBQWEsRUFBRSxJQUFJO01BQ25CQyxVQUFVLEVBQUUsQ0FBQztNQUNiQyxPQUFPLEVBQUUsS0FBSztNQUNkQyxhQUFhLEVBQUUsSUFBSTtNQUNuQkMsYUFBYSxFQUFFLElBQUk7TUFDbkJDLFFBQVEsRUFBRTtJQUNaLENBQUM7RUFDSDtFQUdBLE9BQU9DLFdBQVdBLENBQUEsRUFBMEI7SUFDMUMsSUFBSSxDQUFDbkIscUJBQXFCLENBQUNvQixRQUFRLEVBQUU7TUFDbkNwQixxQkFBcUIsQ0FBQ29CLFFBQVEsR0FBRyxJQUFJcEIscUJBQXFCLENBQUMsQ0FBQztJQUM5RDtJQUNBLE9BQU9BLHFCQUFxQixDQUFDb0IsUUFBUTtFQUN2QztFQUVBLE1BQU1D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