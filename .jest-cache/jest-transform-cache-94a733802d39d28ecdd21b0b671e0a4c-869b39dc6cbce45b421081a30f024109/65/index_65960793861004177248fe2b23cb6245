acc5411ba804b4252e19999f9567133e
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _actCompat = require("./act-compat");
var _pure = require("./pure");
Object.keys(_pure).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _pure[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pure[key];
    }
  });
});
// if we're running in a test runner that supports afterEach
// or teardown then we'll automatically run cleanup afterEach test
// this ensures that tests run in isolation from each other
// if you don't like this then either import the `pure` module
// or set the RTL_SKIP_AUTO_CLEANUP env variable to 'true'.
if (typeof process === 'undefined' || !process.env?.RTL_SKIP_AUTO_CLEANUP) {
  // ignore teardown() in code coverage because Jest does not support it
  /* istanbul ignore else */
  if (typeof afterEach === 'function') {
    afterEach(() => {
      (0, _pure.cleanup)();
    });
  } else if (typeof teardown === 'function') {
    // Block is guarded by `typeof` check.
    // eslint does not support `typeof` guards.
    // eslint-disable-next-line no-undef
    teardown(() => {
      (0, _pure.cleanup)();
    });
  }

  // No test setup with other test runners available
  /* istanbul ignore else */
  if (typeof beforeAll === 'function' && typeof afterAll === 'function') {
    // This matches the behavior of React < 18.
    let previousIsReactActEnvironment = (0, _actCompat.getIsReactActEnvironment)();
    beforeAll(() => {
      previousIsReactActEnvironment = (0, _actCompat.getIsReactActEnvironment)();
      (0, _actCompat.setReactActEnvironment)(true);
    });
    afterAll(() => {
      (0, _actCompat.setReactActEnvironment)(previousIsReactActEnvironment);
    });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9hY3RDb21wYXQiLCJyZXF1aXJlIiwiX3B1cmUiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImVudW1lcmFibGUiLCJnZXQiLCJwcm9jZXNzIiwiZW52IiwiUlRMX1NLSVBfQVVUT19DTEVBTlVQIiwiYWZ0ZXJFYWNoIiwiY2xlYW51cCIsInRlYXJkb3duIiwiYmVmb3JlQWxsIiwiYWZ0ZXJBbGwiLCJwcmV2aW91c0lzUmVhY3RBY3RFbnZpcm9ubWVudCIsImdldElzUmVhY3RBY3RFbnZpcm9ubWVudCIsInNldFJlYWN0QWN0RW52aXJvbm1lbnQiXSwic291cmNlcyI6WyJpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfYWN0Q29tcGF0ID0gcmVxdWlyZShcIi4vYWN0LWNvbXBhdFwiKTtcbnZhciBfcHVyZSA9IHJlcXVpcmUoXCIuL3B1cmVcIik7XG5PYmplY3Qua2V5cyhfcHVyZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3B1cmVba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfcHVyZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbi8vIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSB0ZXN0IHJ1bm5lciB0aGF0IHN1cHBvcnRzIGFmdGVyRWFjaFxuLy8gb3IgdGVhcmRvd24gdGhlbiB3ZSdsbCBhdXRvbWF0aWNhbGx5IHJ1biBjbGVhbnVwIGFmdGVyRWFjaCB0ZXN0XG4vLyB0aGlzIGVuc3VyZXMgdGhhdCB0ZXN0cyBydW4gaW4gaXNvbGF0aW9uIGZyb20gZWFjaCBvdGhlclxuLy8gaWYgeW91IGRvbid0IGxpa2UgdGhpcyB0aGVuIGVpdGhlciBpbXBvcnQgdGhlIGBwdXJlYCBtb2R1bGVcbi8vIG9yIHNldCB0aGUgUlRMX1NLSVBfQVVUT19DTEVBTlVQIGVudiB2YXJpYWJsZSB0byAndHJ1ZScuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8ICFwcm9jZXNzLmVudj8uUlRMX1NLSVBfQVVUT19DTEVBTlVQKSB7XG4gIC8vIGlnbm9yZSB0ZWFyZG93bigpIGluIGNvZGUgY292ZXJhZ2UgYmVjYXVzZSBKZXN0IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBhZnRlckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgKDAsIF9wdXJlLmNsZWFudXApKCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRlYXJkb3duID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQmxvY2sgaXMgZ3VhcmRlZCBieSBgdHlwZW9mYCBjaGVjay5cbiAgICAvLyBlc2xpbnQgZG9lcyBub3Qgc3VwcG9ydCBgdHlwZW9mYCBndWFyZHMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdGVhcmRvd24oKCkgPT4ge1xuICAgICAgKDAsIF9wdXJlLmNsZWFudXApKCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBObyB0ZXN0IHNldHVwIHdpdGggb3RoZXIgdGVzdCBydW5uZXJzIGF2YWlsYWJsZVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGJlZm9yZUFsbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYWZ0ZXJBbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW9yIG9mIFJlYWN0IDwgMTguXG4gICAgbGV0IHByZXZpb3VzSXNSZWFjdEFjdEVudmlyb25tZW50ID0gKDAsIF9hY3RDb21wYXQuZ2V0SXNSZWFjdEFjdEVudmlyb25tZW50KSgpO1xuICAgIGJlZm9yZUFsbCgoKSA9PiB7XG4gICAgICBwcmV2aW91c0lzUmVhY3RBY3RFbnZpcm9ubWVudCA9ICgwLCBfYWN0Q29tcGF0LmdldElzUmVhY3RBY3RFbnZpcm9ubWVudCkoKTtcbiAgICAgICgwLCBfYWN0Q29tcGF0LnNldFJlYWN0QWN0RW52aXJvbm1lbnQpKHRydWUpO1xuICAgIH0pO1xuICAgIGFmdGVyQWxsKCgpID0+IHtcbiAgICAgICgwLCBfYWN0Q29tcGF0LnNldFJlYWN0QWN0RW52aXJvbm1lbnQpKHByZXZpb3VzSXNSZWFjdEFjdEVudmlyb25tZW50KTtcbiAgICB9KTtcbiAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWkEsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sRUFBRSxZQUFZLEVBQUU7RUFDM0NDLEtBQUssRUFBRTtBQUNULENBQUMsQ0FBQztBQUNGLElBQUlDLFVBQVUsR0FBR0MsT0FBTyxDQUFDLGNBQWMsQ0FBQztBQUN4QyxJQUFJQyxLQUFLLEdBQUdELE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDN0JMLE1BQU0sQ0FBQ08sSUFBSSxDQUFDRCxLQUFLLENBQUMsQ0FBQ0UsT0FBTyxDQUFDLFVBQVVDLEdBQUcsRUFBRTtFQUN4QyxJQUFJQSxHQUFHLEtBQUssU0FBUyxJQUFJQSxHQUFHLEtBQUssWUFBWSxFQUFFO0VBQy9DLElBQUlBLEdBQUcsSUFBSVAsT0FBTyxJQUFJQSxPQUFPLENBQUNPLEdBQUcsQ0FBQyxLQUFLSCxLQUFLLENBQUNHLEdBQUcsQ0FBQyxFQUFFO0VBQ25EVCxNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFTyxHQUFHLEVBQUU7SUFDbENDLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFZO01BQ2YsT0FBT0wsS0FBSyxDQUFDRyxHQUFHLENBQUM7SUFDbkI7RUFDRixDQUFDLENBQUM7QUFDSixDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPRyxPQUFPLEtBQUssV0FBVyxJQUFJLENBQUNBLE9BQU8sQ0FBQ0MsR0FBRyxFQUFFQyxxQkFBcUIsRUFBRTtFQUN6RTtFQUNBO0VBQ0EsSUFBSSxPQUFPQyxTQUFTLEtBQUssVUFBVSxFQUFFO0lBQ25DQSxTQUFTLENBQUMsTUFBTTtNQUNkLENBQUMsQ0FBQyxFQUFFVCxLQUFLLENBQUNVLE9BQU8sRUFBRSxDQUFDO0lBQ3RCLENBQUMsQ0FBQztFQUNKLENBQUMsTUFBTSxJQUFJLE9BQU9DLFFBQVEsS0FBSyxVQUFVLEVBQUU7SUFDekM7SUFDQTtJQUNBO0lBQ0FBLFFBQVEsQ0FBQyxNQUFNO01BQ2IsQ0FBQyxDQUFDLEVBQUVYLEtBQUssQ0FBQ1UsT0FBTyxFQUFFLENBQUM7SUFDdEIsQ0FBQyxDQUFDO0VBQ0o7O0VBRUE7RUFDQTtFQUNBLElBQUksT0FBT0UsU0FBUyxLQUFLLFVBQVUsSUFBSSxPQUFPQyxRQUFRLEtBQUssVUFBVSxFQUFFO0lBQ3JFO0lBQ0EsSUFBSUMsNkJBQTZCLEdBQUcsQ0FBQyxDQUFDLEVBQUVoQixVQUFVLENBQUNpQix3QkFBd0IsRUFBRSxDQUFDO0lBQzlFSCxTQUFTLENBQUMsTUFBTTtNQUNkRSw2QkFBNkIsR0FBRyxDQUFDLENBQUMsRUFBRWhCLFVBQVUsQ0FBQ2lCLHdCQUF3QixFQUFFLENBQUM7TUFDMUUsQ0FBQyxDQUFDLEVBQUVqQixVQUFVLENBQUNrQixzQkFBc0IsRUFBRSxJQUFJLENBQUM7SUFDOUMsQ0FBQyxDQUFDO0lBQ0ZILFFBQVEsQ0FBQyxNQUFNO01BQ2IsQ0FBQyxDQUFDLEVBQUVmLFVBQVUsQ0FBQ2tCLHNCQUFzQixFQUFFRiw2QkFBNkIsQ0FBQztJQUN2RSxDQUFDLENBQUM7RUFDSjtBQUNGIiwiaWdub3JlTGlzdCI6W119